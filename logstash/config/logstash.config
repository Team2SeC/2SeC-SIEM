#==============================================================================
# 2SeC SIEM Logstash Pipeline Configuration
# CloudWatch Logs → Kinesis → Logstash → OpenSearch
#==============================================================================

############################
# INPUT
############################
input {
  kinesis {
    kinesis_stream_name => "${KINESIS_STREAM_NAME}"
    region              => "${AWS_REGION}"
    application_name    => "${PROJECT_NAME}-logstash-consumer"

    codec => plain {
      charset => "ISO-8859-1"
    }

    tags => ["kinesis", "cloudwatch"]
  }
}

############################
# FILTER
############################
filter {

  #--------------------------------------------------------------------------
  # 0. CloudWatch Logs Subscription payload decode (base64 + gzip)
  #--------------------------------------------------------------------------
  ruby {
    code => "
      require 'json'
      require 'base64'
      require 'zlib'
      require 'stringio'

      msg = event.get('message')

      begin
        parsed = JSON.parse(msg) rescue nil

        if parsed && parsed.dig('awslogs', 'data')
          raw = Base64.decode64(parsed['awslogs']['data'])
          json_str = Zlib::GzipReader.new(StringIO.new(raw)).read

          event.set('[@metadata][cw_payload]', json_str)
          event.remove('message')
        end
      rescue => e
        event.tag('decode_failed')
        event.set('[@metadata][decode_error]', e.message)
      end
    "
  }

  #--------------------------------------------------------------------------
  # 1. CloudWatch payload JSON 파싱
  #--------------------------------------------------------------------------
  if [@metadata][cw_payload] {
    json {
      source => "[@metadata][cw_payload]"
      target => "cw"
      ecs_compatibility => disabled
    }
  }

  #--------------------------------------------------------------------------
  # 2. logEvents 배열 분해 (핵심)
  #--------------------------------------------------------------------------
  if [cw][logEvents] {
    split {
      field => "[cw][logEvents]"
    }

    mutate {
      replace => {
        "message" => "%{[cw][logEvents][message]}"
      }
    }

    date {
      match  => ["[cw][logEvents][timestamp]", "UNIX_MS"]
      target => "@timestamp"
    }
  }

  #--------------------------------------------------------------------------
  # 3. 웹 로그 파싱 (Apache / Nginx Combined)
  #--------------------------------------------------------------------------
  grok {
    match => {
      "message" => "%{IPORHOST:[source][ip]} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"%{WORD:[http][request][method]} %{NOTSPACE:[url][original]} HTTP/%{NUMBER:[http][version]}\" %{NUMBER:[http][response][status_code]} (?:%{NUMBER:[http][response][body][bytes]}|-)"
    }
    add_tag => ["web_parsed"]
    ecs_compatibility => disabled
  }

  #--------------------------------------------------------------------------
  # 4. URL / UA / GeoIP
  #--------------------------------------------------------------------------
  if [url][original] {
    ruby {
      code => "
        require 'uri'
        begin
          uri = URI.parse(event.get('[url][original]'))
          event.set('[url][path]', uri.path)
          event.set('[url][query]', uri.query) if uri.query
        rescue
          event.tag('url_parse_error')
        end
      "
    }
  }

  if [source][ip] {
    geoip {
      source => "[source][ip]"
      target => "[source][geo]"
      ecs_compatibility => disabled
    }
  }

  #--------------------------------------------------------------------------
  # 5. 기본 필드 / ECS 성격 필드
  #--------------------------------------------------------------------------
  mutate {
    add_field => {
      "pipeline"          => "${PROJECT_NAME}-logstash"
      "[event][kind]"     => "event"
      "[event][category]" => "web"
      "[event][dataset]"  => "web.access"
    }

    remove_field => [
      "@version",
      "cw",
      "ident",
      "auth"
   ]
  }

  #--------------------------------------------------------------------------
  # 6. 공격 탐지 엔진 (YAML 기반)
  #--------------------------------------------------------------------------
#  ruby {
#  init => "
#     require '/usr/share/logstash/patterns/patterns_matcher.rb'
#     @matcher = AttackPatternMatcher.new(
#       '/usr/share/logstash/patterns/attack_patterns.yml',
#       '/usr/share/logstash/patterns/severity_mapping.yml'
#     )
#   "
#   code => "
#     msg = event.get('message').to_s
#     ip  = event.get('[source][ip]')

#     attacks = @matcher.detect_attacks(msg, ip)

#     if attacks.empty?
#       event.set('[event][type]', 'access')
#       event.set('[event][outcome]', 'success')
#       event.set('severity', 'info')
#       event.set('[engine][status]', 'active')
#       event.tag('normal')
#     else
#       event.set('[event][type]', 'attack')
#       event.set('[event][outcome]', 'unknown')
#       event.set('[engine][status]', 'active')
#       event.set('[attack][technique]', a['technique'])
#       event.set('[attack][confidence]', a['confidence'])
#
#       event.tag('attack')
#     end
#    "
#  }

  #--------------------------------------------------------------------------
  # 7. HTTP 응답 코드 기반 결과 판단
  #--------------------------------------------------------------------------
  if [http][response][status_code] {
    ruby {
      code => "
        code = event.get('[http][response][status_code]').to_i
        if event.get('tags')&.include?('attack')
          event.set('[event][outcome]', code < 300 ? 'success' : 'failure')
        else
          event.set('[event][outcome]', code < 400 ? 'success' : 'failure')
        end
      "
    }
  }
}

############################
# OUTPUT
############################
output {
  opensearch {
    hosts => ["https://${OPENSEARCH_HOST}:443"]
    index => "2sec-siem-%{+yyyy.MM.dd}"

    auth_type => {
      type   => "aws_iam"
      region => "${AWS_REGION}"
    }

    ecs_compatibility => disabled
    manage_template   => false
  }
}