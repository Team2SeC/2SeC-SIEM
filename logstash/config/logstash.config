# Logstash Pipeline
# Kinesis (gzip) → CloudWatch JSON → split(logEvents) → grok/geoip → OpenSearch

input {
  kinesis {
    kinesis_stream_name => "${KINESIS_STREAM_NAME}"
    region              => "${AWS_REGION}"
    application_name    => "${APPLICATION_NAME}"

    codec => gzip {
      charset => "UTF-8"
    }
  }
}

filter {

  # --------------------------------------------------
  # 공통 메타데이터
  # --------------------------------------------------
  mutate {
    add_field => { "ingest_source" => "kinesis" }
  }

  # --------------------------------------------------
  # CloudWatch JSON 파싱
  # --------------------------------------------------
  json {
    source         => "message"
    target         => "parsed"
    tag_on_failure => ["_cloudwatch_json_failure"]
  }

  # --------------------------------------------------
  # dvwa-app 로그만 대상으로 처리 (⭐ split 전에 drop)
  # --------------------------------------------------
  if ![parsed][logStream] or [parsed][logStream] !~ "dvwa-app" {
    drop { }
  }

  # --------------------------------------------------
  # logEvents 배열 분리 (⭐ 핵심)
  # 이벤트 1개 = 웹 로그 1줄
  # --------------------------------------------------
  if [parsed][logEvents] {
    split { field => "[parsed][logEvents]" }
  } else {
    drop { }
  }

  # --------------------------------------------------
  # CloudWatch logEvent timestamp를 @timestamp로 보정
  # (UNIX_MS 기반)
  # --------------------------------------------------
  if [parsed][logEvents][timestamp] {
    date {
      match  => ["[parsed][logEvents][timestamp]", "UNIX_MS"]
      target => "@timestamp"
    }
  }

  ###########################################################################
  # 4 Apache Combined grok (cw logEvents로 정규화된 message만)
  ###########################################################################
  if "no_cw_logevents" not in [tags] and "cw_decode_failed" not in [tags] and "cw_control_message" not in [tags] {
    grok {
      match => {
        "message" => "%{IPORHOST:[source][ip]} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:[http][timestamp]}\\] \"%{WORD:[http][request][method]} %{NOTSPACE:[url][original]} HTTP/%{NUMBER:[http][version]}\" %{NUMBER:[http][response][status_code]} (?:%{NUMBER:[http][response][body][bytes]}|-) \"(?:%{NOTSPACE:[http][request][referrer]}|-)\" \"%{DATA:[user_agent][original]}\""
      }
      add_tag => ["web_parsed"]
      ecs_compatibility => disabled
  # --------------------------------------------------
  # 실제 웹 로그 메시지 추출
  # --------------------------------------------------
  mutate {
    rename => { "[parsed][logEvents][message]" => "raw_message" }
  }

  # --------------------------------------------------
  # Web Access Log 파싱 (COMBINEDAPACHELOG)
  # --------------------------------------------------
  grok {
    match => { "raw_message" => "%{COMBINEDAPACHELOG}" }
    remove_field => ["timestamp"]
    tag_on_failure => ["_grok_web_failed"]
  }

  # grok 실패 이벤트는 일단 유지(디버깅).
  # 운영에서 깨끗한 데이터만 원하면 아래 주석 해제:
  # if "_grok_web_failed" in [tags] { drop {} }

  # --------------------------------------------------
  # SIEM 스키마 정규화
  # - clientip/verb/response/bytes/referrer/agent 등 표준화
  # - request는 'GET /path?query HTTP/1.1' 형태이므로
  #   url.original은 path+query로 재구성해서 "원문 URL"로 유지
  # --------------------------------------------------

  # clientip → ECS 유사: source.address
  mutate {
    rename => {
      "clientip" => "[source][address]"
      "verb"     => "[http][request][method]"
      "response" => "[http][response][status_code]"
      "bytes"    => "[http][response][body][bytes]"
      "referrer" => "[http][request][referrer]"
      "agent"    => "[user_agent][original]"
    }
  }

 grok {
    match => {
      "raw_message" =>
        "\"%{WORD:[http][request][method]} %{URIPATH:url.path}(?:\?%{DATA:url.query})? HTTP/%{NUMBER:http.version}\""
    }
  }

  if [url][path] and [url][query] {
    mutate { replace => { "[url][original]" => "%{[url][path]}?%{[url][query]}" } }
  } else if [url][path] {
    mutate { replace => { "[url][original]" => "%{[url][path]}" } }
  }

  if [source][address] {
    geoip {
      source => "[source][address]"
      target => "geoip"
    }
  }


  # --------------------------------------------------
  # 공통 탐지 필드 초기화 (모든 요청에 적용)
  # --------------------------------------------------
  mutate {
    add_field => {
      "detection_stage"   => "classification"
      "detection_source"  => "logstash"
    }
    add_tag => ["web", "dvwa"]
  }

# --------------------------------------------------
  # WEB-SQLI-001: SQL Injection 탐지
# --------------------------------------------------

  # SQL Injection 패턴 탐지 (GET, POST 요청 대상)
  if [url][query] and 
  ([http][request][method] == "GET" or [http][request][method] == "POST") and 
  ([http][response][status_code] == "200" or [http][response][status_code] == "500") {
  
    if [url][query] =~ /(?i)(union\s+select|'\s*or\s+1\s*=\s*1|\'\s*or\s+\'\s*1\s*\'\s*=\s*\'\s*1|;\s*drop\s+table|;\s*delete\s+from|admin\'\s*--|\'\s*;\s*--|benchmark\(|sleep\(|waitfor\s+delay|information_schema)/ {
      mutate {
        add_field => {
          "attack_category"  => "Injection"
          "attack_type"      => "SQL Injection"
          "attack_rule_id"   => "WEB-SQLI-001"
          "attack_severity"  => "medium"
        }
        add_tag => ["sqli_detected"]
      }
    }
  }

# --------------------------------------------------
# WEB-XSS-001: Cross-Site Scripting 탐지
# --------------------------------------------------

  # 조건 1: Query 파라미터 존재 + HTTP 메소드(GET/POST) + 응답코드(200/500)
  if [url][query] and 
    ([http][request][method] == "GET" or [http][request][method] == "POST") and 
    ([http][response][status_code] == "200" or [http][response][status_code] == "500") {
    
    # 조건 2: XSS 패턴 매칭
    if [url][query] =~ /(?i)(script|javascript|onload|onerror|onclick|alert|prompt|confirm|eval|%3C|&lt;)/ {

      mutate {
        add_field => {
          "attack_category"  => "Client-side"
          "attack_type"      => "Cross-Site Scripting"
          "attack_rule_id"   => "WEB-XSS-001"
          "attack_severity"  => "medium"
        }
        add_tag => ["xss_detected"]
      }
    }
  }

# --------------------------------------------------
  # WEB-PATH-001: Path Traversal / LFI 탐지
# --------------------------------------------------
  
  # Path Traversal 패턴 탐지 (GET, POST 요청 대상)
  if ([http][request][method] == "GET" or [http][request][method] == "POST") and ([http][response][status_code] == "200" or [http][response][status_code] == "403" or [http][response][status_code] == "404" or [http][response][status_code] == "500") {
 
    # URL 경로에서 디렉터리 이동 패턴 확인
    if ([url][path] and [url][path] =~ /(?i)(\.\.\/|%2e%2e|\.\.%2f|\.\.%5c)/) or
       ([url][query] and [url][query] =~ /(?i)(\.\.\/|%2e%2e|\/etc\/passwd|\/etc\/hosts|boot\.ini|windows|file=\.\.|page=\.\.|path=\.\.)/) {
      mutate {
        add_field => {
          "attack_category"  => "File Access"
          "attack_type"      => "Path Traversal"
          "attack_rule_id"   => "WEB-PATH-001"
          "attack_severity"  => "medium"
        }
        add_tag => ["path_traversal_detected"]
      }
    }
  }

# --------------------------------------------------
  # WEB-CMD-001: Command Injection 탐지
# --------------------------------------------------

  # 조건 1: Query 파라미터 존재 + HTTP 메소드(GET/POST) + 응답코드(200/500)
  if [url][query] and 
    ([http][request][method] == "GET" or [http][request][method] == "POST") and 
    ([http][response][status_code] == "200" or [http][response][status_code] == "500") {
 
    if [url][query] =~ /(?i)(;whoami|;id|;ls|;cat|;pwd|\|whoami|\|id|\|ls|%3bwhoami|%3bid|%7cwhoami|%7cid|&&whoami|&&id)/ {
    
      mutate {
        add_field => {
          "attack_category"  => "Injection"
          "attack_type"      => "Command Injection"
          "attack_rule_id"   => "WEB-CMD-001"
          "attack_severity"  => "high"
        }
        add_tag => ["cmd_injection_detected"]
      }
    }
  }

# --------------------------------------------------
  # WEB-SCAN-001: Web Scanning / Reconnaissance 탐지
# --------------------------------------------------

  # 조건 1: HTTP 메소드(GET/HEAD) + 응답코드(404/403)
  if ([http][request][method] == "GET" or [http][request][method] == "HEAD") and 
    ([http][response][status_code] == "404" or [http][response][status_code] == "403") {
  
  # 조건 2: 민감 경로 접근 또는 스캐너 User-Agent 탐지
    # 민감 경로 접근 탐지
    if ([url][path] and [url][path] =~ /(?i)(\/phpmyadmin|\/wp-admin|\/admin|\/config|\/backup|\/test|\/debug|\/phpinfo|\/manager|\/console|\/login|\/wp-login|\/administrator|\/webmin|\/cpanel|\/mysql|\/database|\.bak|\.sql|\.zip)/) or
       # 스캐너 User-Agent 탐지
       ([user_agent][original] and [user_agent][original] =~ /(?i)(sqlmap|nikto|nmap|dirb|dirbuster|gobuster|wfuzz|burp|w3af|curl|wget|python|scanner|bot|crawl)/) {
      mutate {
        add_field => {
          "attack_category"  => "Reconnaissance"
          "attack_type"      => "Web Scanning"
          "attack_rule_id"   => "WEB-SCAN-001"
          "attack_severity"  => "low"
        }
        add_tag => ["web_scan_detected"]
      }
    }
  }

# --------------------------------------------------
  # WEB-404-001: Repeated 404 Access / Reconnaissance 탐지
# --------------------------------------------------
  
  # 404 상태코드 기반 정찰 행위 탐지 (GET, HEAD 요청 대상)
  if ([http][request][method] == "GET" or [http][request][method] == "HEAD") and [http][response][status_code] == "404" {
    mutate {
      add_field => {
        "attack_category"  => "Reconnaissance"
        "attack_type"      => "Repeated 404 Access"
        "attack_rule_id"   => "WEB-404-001"
        "attack_severity"  => "low"
      }
      add_tag => ["repeated_404_detected"]
    }
  }

# --------------------------------------------------
  # WEB-UA-001: Suspicious User-Agent 탐지
# --------------------------------------------------
  
  # 의심스러운 User-Agent 탐지 (GET, POST, HEAD 요청 대상)
  if ([http][request][method] == "GET" or [http][request][method] == "POST" or [http][request][method] == "HEAD") and [user_agent][original] {
    if [user_agent][original] =~ /(?i)(sqlmap|nikto|nmap|dirb|dirbuster|gobuster|wfuzz|burp|w3af|curl|wget|python-requests|libwww|Go-http-client|Java\/|scanner|bot|crawl|masscan|zmap|nuclei|acunetix|nessus|openvas|whatweb|httpx|subfinder)/ {
      mutate {
        add_field => {
          "attack_category"  => "Reconnaissance"
          "attack_type"      => "Suspicious User-Agent"
          "attack_rule_id"   => "WEB-UA-001"
          "attack_severity"  => "low"
        }
        add_tag => ["suspicious_ua_detected"]
      }
    }
  }

# --------------------------------------------------
  # WEB-AUTH-001: Authentication Abuse / Login Bruteforce 탐지
# --------------------------------------------------
  
  # 조건 1: HTTP 메소드(POST/GET) + 인증 경로 + 응답코드(401/403/200)
  if ([http][request][method] == "POST" or [http][request][method] == "GET") and [url][path] and
    ([http][response][status_code] == "401" or [http][response][status_code] == "403" or [http][response][status_code] == "200") {
  
  # 조건 2: 로그인 관련 경로 패턴 매칭
    if [url][path] =~ /(?i)(\/login\.php|\/login|\/auth|\/signin|\/sign-in|\/logon|\/authentication|\/user\/login|\/admin\/login|\/wp-login|\/account\/login|\/portal\/login|\/system\/login)/ {
      mutate {
        add_field => {
          "attack_category"  => "Authentication Abuse"
          "attack_type"      => "Login Bruteforce"
          "attack_rule_id"   => "WEB-AUTH-001"
          "attack_severity"  => "high"
        }
        add_tag => ["auth_abuse_detected"]
      }
    }
  }

# --------------------------------------------------
  # WEB-TIMEOUT-001: Repeated 408 / Slow Request 탐지
# --------------------------------------------------
  
  # Slow Request / 408 Timeout 탐지 (GET, POST, HEAD 요청 대상)
  if ([http][request][method] == "GET" or [http][request][method] == "POST" or [http][request][method] == "HEAD") and [http][response][status_code] == "408" {
    mutate {
      add_field => {
        "attack_category"  => "Availability"
        "attack_type"      => "Slow Request"
        "attack_rule_id"   => "WEB-TIMEOUT-001"
        "attack_severity"  => "medium"
      }
      add_tag => ["timeout_detected"]
    }
  }

  # --------------------------------------------------
  # 정상 요청 분류 (공격이 탐지되지 않은 경우)
  # --------------------------------------------------
  if "sqli_detected" not in [tags] and "xss_detected" not in [tags] and "path_traversal_detected" not in [tags] and "cmd_injection_detected" not in [tags] and "web_scan_detected" not in [tags] and "repeated_404_detected" not in [tags] and "suspicious_ua_detected" not in [tags] and "auth_abuse_detected" not in [tags] and "timeout_detected" not in [tags] {
    mutate {
      add_field => {
        "attack_category" => "Normal"
        "attack_type"     => "Legitimate Request"
        "attack_rule_id"  => "WEB-NORMAL-001"
        "attack_severity" => "info"
      }
      add_tag => ["normal_request"]
    }
  }

  ###########################################################################
  # 8 Attack Detection Rules (Classification Layer - Level 1)
  ###########################################################################
  if "web_parsed" in [tags] {

    # 공통 필드 초기화
    mutate {
      add_field => {
        "[detection][stage]"   => "classification"
        "[detection][source]"  => "logstash"
        "[detection][version]" => "v1.0"
      }
    }

    # ----- WEB-SQLI-001: SQL Injection -----
    if [url][query] =~ /(?i)(union\s+select|' or 1=1|' or '1'='1|sleep\(|benchmark\(|concat\(|group_concat\(|0x[0-9a-f]+|waitfor\s+delay|exec\(|execute\(|information_schema|sysobjects|syscolumns)/ {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-SQLI-001"
          "[attack][type]"       => "SQL Injection"
          "[attack][category]"   => "Injection"
          "[attack][severity]"   => "medium"
          "[attack][confidence]" => "medium"
        }
        add_tag => ["attack", "sqli"]
      }
    }

    # ----- WEB-XSS-001: Cross-Site Scripting -----
    if [url][query] =~ /(?i)(<script|<\/script>|javascript:|onerror=|onload=|onmouseover=|onfocus=|onblur=|onclick=|<img|<svg|<iframe|<object|<embed|%3Cscript|%3Cimg|%3Csvg|%3Ciframe|&#60;script&#62;|&#x3C;script&#x3E;)/ {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-XSS-001"
          "[attack][type]"       => "Cross-Site Scripting"
          "[attack][category]"   => "Client-Side"
          "[attack][severity]"   => "medium"
          "[attack][confidence]" => "medium"
        }
        add_tag => ["attack", "xss"]
      }
    }

    # ----- WEB-CMD-001: Command Injection -----
    if [url][query] =~ /(?i)(;|\||&&|\|\||`|\$\()(whoami|id|ls|cat|pwd|uname|hostname|ifconfig|netstat|ps|wget|curl|nc|bash|sh|dir|type|ipconfig|net|ping|tasklist|cmd|powershell)/ {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-CMD-001"
          "[attack][type]"       => "Command Injection"
          "[attack][category]"   => "Injection"
          "[attack][severity]"   => "high"
          "[attack][confidence]" => "high"
        }
        add_tag => ["attack", "cmdi"]
      }
    }

    # ----- WEB-PATH-001: Path Traversal / LFI -----
    if [url][path] =~ /\.\.\/|\.\.\\|%2e%2e/ or [url][query] =~ /(?i)(\.\.\/|\.\.\\|%2e%2e|\/etc\/passwd|boot\.ini|\/etc\/shadow|\/proc\/|C:\\|\.\.%2F)/ {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-PATH-001"
          "[attack][type]"       => "Path Traversal"
          "[attack][category]"   => "File Access"
          "[attack][severity]"   => "medium"
          "[attack][confidence]" => "medium"
        }
        add_tag => ["attack", "path_traversal"]
      }
    }

    # ----- WEB-SCAN-001: Web Scanning -----
    # 관리자 페이지, 민감 파일, 백업 경로, API 문서, 개발 경로 등 탐지
    if [url][path] =~ /(?i)(\/phpmyadmin|\/wp-admin|\/wp-login\.php|\/admin|\/administrator|\/manager|\/control-panel|\/cpanel|\/\.git|\/\.env|\/\.env\.production|\/config|\/configuration\.php|\/wp-config\.php|\/settings\.py|\/backup|\/backup\.zip|\/backup\.tar\.gz|\/db_backup\.sql|\/\.bak|\/old|\/api|\/api\/v1|\/api\/swagger|\/api-docs|\/swagger-ui|\/graphql|\/graphql-playground|\/test|\/dev|\/debug|\/phpinfo\.php|\/info\.php|\/test\.php|\/server-status|\/server-info|\/status|\/health|\/metrics)/ and [http][response][status_code] =~ /^(403|404)$/ {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-SCAN-001"
          "[attack][type]"       => "Web Scanning"
          "[attack][category]"   => "Reconnaissance"
          "[attack][severity]"   => "low"
          "[attack][confidence]" => "low"
        }
        add_tag => ["attack", "scan"]
      }
    }

    # ----- WEB-UA-001: Suspicious User-Agent -----
    # 취약점 스캐너, 디렉터리 브루트포스, 스크립트 클라이언트, 봇 등 탐지
    if [user_agent][original] =~ /(?i)(sqlmap|nikto|nmap|masscan|nessus|acunetix|nuclei|burp|zap|w3af|openvas|dirb|gobuster|wfuzz|dirsearch|ffuf|curl|wget|python-requests|python-urllib|Go-http-client|Apache-HttpClient|Java\/|libwww-perl|bot|spider|crawler|scraper|scanner|scrapy)/ {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-UA-001"
          "[attack][type]"       => "Suspicious User-Agent"
          "[attack][category]"   => "Reconnaissance"
          "[attack][severity]"   => "low"
          "[attack][confidence]" => "low"
        }
        add_tag => ["attack", "suspicious_ua"]
      }
    }

    # 명시적 스캐너 UA는 confidence 상승
    if [user_agent][original] =~ /(?i)(sqlmap|nikto|acunetix|nessus|nuclei|openvas)/ {
      mutate {
        update => { "[attack][confidence]" => "high" }
        update => { "[attack][severity]" => "medium" }
      }
    }

    # ----- WEB-404-001: Repeated 404 Access -----
    if [http][response][status_code] == "404" {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-404-001"
          "[attack][type]"       => "Repeated 404 Access"
          "[attack][category]"   => "Reconnaissance"
          "[attack][severity]"   => "low"
          "[attack][confidence]" => "low"
        }
        add_tag => ["attack", "repeated_404"]
      }
    }

    # ----- WEB-AUTH-001: Login Bruteforce -----
    # 일반 로그인, 관리자 로그인, API 인증, CMS별 로그인 경로 탐지
    if [url][path] =~ /(?i)(\/login\.php|\/login\.html|\/login|\/signin|\/sign-in|\/sign_in|\/logon|\/logon\.php|\/authenticate|\/authentication|\/auth|\/admin\/login|\/administrator\/login|\/wp-admin|\/wp-login\.php|\/manager\/login|\/control-panel\/login|\/api\/auth|\/api\/login|\/api\/v1\/authenticate|\/api\/v1\/token|\/oauth\/token|\/user\/login)/ and [http][request][method] == "POST" {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-AUTH-001"
          "[attack][type]"       => "Login Bruteforce"
          "[attack][category]"   => "Authentication Abuse"
          "[attack][severity]"   => "high"
          "[attack][confidence]" => "low"
        }
        add_tag => ["attack", "auth_bruteforce"]
      }
    }

    # 관리자 로그인 경로는 severity 더 높게
    if "auth_bruteforce" in [tags] and [url][path] =~ /(?i)(\/admin|\/administrator|\/wp-admin|\/manager)/ {
      mutate {
        update => { "[attack][severity]" => "critical" }
      }
    }

    # ----- WEB-TIMEOUT-001: Slow Request / Timeout -----
    if [http][response][status_code] == "408" {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-TIMEOUT-001"
          "[attack][type]"       => "Slow Request"
          "[attack][category]"   => "Availability"
          "[attack][severity]"   => "medium"
          "[attack][confidence]" => "low"
        }
        add_tag => ["attack", "timeout"]
      }
    }

    # Confidence 조정 로직
    if "attack" in [tags] {
      ruby {
        code => "
          # 복수 공격 패턴 감지 시 confidence 상승
          attack_tags = event.get('tags').select { |t| t =~ /^(sqli|xss|cmdi|path_traversal|scan|suspicious_ua|repeated_404|auth_bruteforce|timeout)$/ }

          if attack_tags.length >= 2
            event.set('[attack][confidence]', 'high')
          end

          # URL 인코딩이 포함된 경우 confidence 상승
          url_query = event.get('[url][query]').to_s
          if url_query =~ /%[0-9a-fA-F]{2}/
            current_confidence = event.get('[attack][confidence]')
            if current_confidence == 'low'
              event.set('[attack][confidence]', 'medium')
            elsif current_confidence == 'medium'
              event.set('[attack][confidence]', 'high')
            end
          end
        "
      }
    }
  }
}

output {
  opensearch {
    hosts => ["https://${OPENSEARCH_HOST}:443"]
    index => "2sec-siem-%{+yyyy.MM.dd}"

    auth_type => {
      type   => "aws_iam"
      region => "${AWS_REGION}"
    }

    ecs_compatibility => disabled
    manage_template   => false
  }
}