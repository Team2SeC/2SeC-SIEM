# Logstash Pipeline
# Kinesis (gzip) → CloudWatch JSON → split(logEvents) → grok/geoip → OpenSearch

input {
  kinesis {
    kinesis_stream_name => "${KINESIS_STREAM_NAME}"
    region              => "${AWS_REGION}"
    application_name    => "${APPLICATION_NAME}"

    codec => gzip {
      charset => "UTF-8"
    }
  }
}

filter {

  # --------------------------------------------------
  # 공통 메타데이터
  # --------------------------------------------------
  mutate {
    add_field => { "ingest_source" => "kinesis" }
  }

  # --------------------------------------------------
  # CloudWatch JSON 파싱
  # --------------------------------------------------
  json {
    source         => "message"
    target         => "parsed"
    tag_on_failure => ["_cloudwatch_json_failure"]
  }

  # --------------------------------------------------
  # dvwa-app 로그만 대상으로 처리 (⭐ split 전에 drop)
  # --------------------------------------------------
  if ![parsed][logStream] or [parsed][logStream] !~ "dvwa-app" {
    drop { }
  }

  # --------------------------------------------------
  # logEvents 배열 분리 (⭐ 핵심)
  # 이벤트 1개 = 웹 로그 1줄
  # --------------------------------------------------
  if [parsed][logEvents] {
    split { field => "[parsed][logEvents]" }
  } else {
    drop { }
  }

  # --------------------------------------------------
  # CloudWatch logEvent timestamp를 @timestamp로 보정
  # (UNIX_MS 기반)
  # --------------------------------------------------
  if [parsed][logEvents][timestamp] {
    date {
      match  => ["[parsed][logEvents][timestamp]", "UNIX_MS"]
      target => "@timestamp"
    }
  }

  # --------------------------------------------------
  # 실제 웹 로그 메시지 추출
  # --------------------------------------------------
  mutate {
    rename => { "[parsed][logEvents][message]" => "raw_message" }
  }

  # --------------------------------------------------
  # Web Access Log만 grok, 나머지는 Error Log로 분리
  # --------------------------------------------------
  if [raw_message] =~ '^\d{1,3}(\.\d{1,3}){3} ' and [raw_message] =~ ' HTTP/' {
    grok {
      match => { "raw_message" => "%{COMBINEDAPACHELOG}" }
      remove_field => ["timestamp"]
      tag_on_failure => ["_grok_web_failed"]
    }

    # --------------------------------------------------
    # SIEM 스키마 정규화
    # - clientip/verb/response/bytes/referrer/agent 등 표준화
    # - request는 'GET /path?query HTTP/1.1' 형태이므로
    #   url.original은 path+query로 재구성해서 "원문 URL"로 유지
    # --------------------------------------------------

    # clientip → ECS 유사: source.address
    mutate {
      rename => {
        "clientip" => "[source][address]"
        "verb"     => "[http][request][method]"
        "response" => "[http][response][status_code]"
        "bytes"    => "[http][response][body][bytes]"
        "referrer" => "[http][request][referrer]"
        "agent"    => "[user_agent][original]"
      }
    }

    if [source][address] and ![source][ip] {
      mutate {
        copy => { "[source][address]" => "[source][ip]" }
      }
    }

    grok {
      match => {
        "raw_message" =>
          "\"%{WORD:[http][request][method]} %{URIPATH:url.path}(?:\?%{DATA:url.query})? HTTP/%{NUMBER:http.version}\""
      }
    }

    if [url][path] and [url][query] {
      mutate { replace => { "[url][original]" => "%{[url][path]}?%{[url][query]}" } }
    } else if [url][path] {
      mutate { replace => { "[url][original]" => "%{[url][path]}" } }
    }
  } else if [raw_message] =~ '^\[.+\] \[:\w+\]' {
    grok {
      match => {
        "raw_message" =>
          "^\[%{DAY:apache.error.day} %{MONTH:apache.error.month} %{MONTHDAY:apache.error.day_num} %{TIME:apache.error.time} %{YEAR:apache.error.year}\] \[%{DATA:apache.error.module}:%{LOGLEVEL:apache.error.level}\] \[pid %{NUMBER:apache.error.pid}\] \[client %{IP:apache.error.client_ip}:%{NUMBER:apache.error.client_port}\] %{GREEDYDATA:apache.error.message}$"
      }
      tag_on_failure => ["_grok_errorlog_failed"]
    }
  } else if [raw_message] =~ '^==> /var/log/apache2/.* <==$' {
    drop { }
  }

  if [source][address] {
    geoip {
      source => "[source][address]"
      target => "geoip"
    }
  }
}

output {
  opensearch {
    hosts => ["https://${OPENSEARCH_HOST}:443"]
    index => "2sec-siem-%{+YYYY.MM.dd}"

    auth_type => {
      type   => "aws_iam"
      region => "${AWS_REGION}"
    }

    ecs_compatibility => disabled
    manage_template   => false
  }
}
