#==============================================================================
# 2SeC SIEM Logstash Pipeline Configuration  
# Kinesis Data Stream â†’ Processing â†’ OpenSearch
#==============================================================================

input {
  kinesis {
    kinesis_stream_name => "${KINESIS_STREAM_NAME}"
    region => "${AWS_REGION}"
    application_name => "${PROJECT_NAME}-logstash-consumer"
    
    codec => json
    tags => ["kinesis", "raw"]  
  }
}

filter {
  #---------------------------------------------------------------------------
  # 1. ê¸°ë³¸ í•„ë“œ ì •ë¦¬
  #---------------------------------------------------------------------------
  mutate {
    remove_field => ["@version", "host", "path", "port", "type"]
    add_field => {
      "pipeline" => "${PROJECT_NAME}-logstash"
      "[event][kind]" => "event"
      "[event][category]" => "web"
      "[event][dataset]" => "web.access"
    }
  }
  
  # íƒ€ìž„ìŠ¤íƒ¬í”„ ì •ê·œí™”
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601"]
      target => "@timestamp"
    }
  }
  
  #---------------------------------------------------------------------------
  # 2. ì›¹ ë¡œê·¸ íŒŒì‹± (Apache/Nginx Combined Log)
  #---------------------------------------------------------------------------
  if [log_type] == "web" {
    grok {
      match => { 
        "message" => "%{IPORHOST:[source][ip]} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] \"(?:%{WORD:[http][request][method]} %{NOTSPACE:[url][original]}(?: HTTP/%{NUMBER:[http][version]})?|%{DATA:rawrequest})\" %{NUMBER:[http][response][status_code]} (?:%{NUMBER:[http][response][body][bytes]}|-) \"(?:%{DATA:[http][request][referrer]}|-)\" \"(?:%{DATA:[user_agent][original]}|-)\""
      }
      add_tag => ["web_parsed"]
    }
    
    # URL íŒŒì‹±
    if [url][original] {
      ruby {
        code => "
          require 'uri'
          url = event.get('[url][original]')
          begin
            uri = URI.parse(url)
            event.set('[url][path]', uri.path)
            event.set('[url][query]', uri.query) if uri.query
          rescue => e
            event.tag('url_parse_error')
          end
        "
      }
    }
    
    # User Agent íŒŒì‹±
    if [user_agent][original] {
      useragent {
        source => "[user_agent][original]"
        target => "[user_agent]"
      }
    }
    
    # GeoIP ë¶„ì„
    if [source][ip] {
      geoip {
        source => "[source][ip]"
        target => "[source][geo]"
      }
    }
  }
  
  
  #---------------------------------------------------------------------------
  # 3. ðŸŽ¯ YAML ê¸°ë°˜ ê³µê²© íƒì§€ ì—”ì§„ (ì˜êµ¬ ë¶ˆë³€!)
  #---------------------------------------------------------------------------
  ruby {
    init => "
      # íŒ¨í„´ ë§¤ì²˜ ì—”ì§„ ì´ˆê¸°í™” (í•œ ë²ˆë§Œ ì‹¤í–‰)
      require_relative '/usr/share/logstash/config/patterns/pattern_matcher.rb'
      
      @pattern_matcher = AttackPatternMatcher.new(
        '/usr/share/logstash/config/patterns/attack_patterns.yml',
        '/usr/share/logstash/config/patterns/severity_mapping.yml'
      )
      
      puts '[INFO] Attack detection engine initialized'
    "
    
    code => "
      # ë©”ì‹œì§€ ë° ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ì¶”ì¶œ
      message = event.get('message').to_s
      source_ip = event.get('[source][ip]')
      
      # ðŸš€ í†µí•© ê³µê²© íƒì§€ ì‹¤í–‰
      detected_attacks = @pattern_matcher.detect_attacks(message, source_ip)
      
      if detected_attacks.empty?
        #-----------------------------------------------------------------------
        # ì •ìƒ íŠ¸ëž˜í”½ ì²˜ë¦¬
        #-----------------------------------------------------------------------
        event.set('[event][type]', 'access')
        event.set('[event][outcome]', 'success')
        event.set('severity', 'info')
        event.tag('normal')
        
      else
        #-----------------------------------------------------------------------  
        # ê³µê²© íƒì§€ ì²˜ë¦¬
        #-----------------------------------------------------------------------
        event.set('[event][type]', 'attack')
        event.set('[event][outcome]', 'unknown')
        
        # ê°€ìž¥ ì‹¬ê°í•œ ê³µê²© ì •ë³´ë¥¼ ë©”ì¸ìœ¼ë¡œ ì„¤ì •
        primary_attack = detected_attacks.first
        event.set('severity', primary_attack['severity'])
        event.set('[attack][category]', primary_attack['category'])
        event.set('[attack][technique]', primary_attack['technique'])
        event.set('[attack][confidence]', primary_attack['confidence'])
        
        # ë‹¤ì¤‘ ê³µê²© íƒì§€ ì‹œ ì¶”ê°€ ì •ë³´ ì €ìž¥
        if detected_attacks.size > 1
          event.set('[attack][multiple_detected]', true)
          event.set('[attack][count]', detected_attacks.size)
          
          # ëª¨ë“  ê³µê²© ì •ë³´ë¥¼ ë°°ì—´ë¡œ ì €ìž¥
          all_attacks = detected_attacks.map do |attack|
            {
              'category' => attack['category'],
              'technique' => attack['technique'], 
              'severity' => attack['severity'],
              'confidence' => attack['confidence']
            }
          end
          event.set('[attack][all_detected]', all_attacks)
          
          # ê³µê²© ì¹´í…Œê³ ë¦¬ ëª©ë¡ (ì§‘ê³„ìš©)
          categories = detected_attacks.map { |a| a['category'] }.uniq
          event.set('[attack][categories]', categories)
        end
        
        event.tag('attack')
      end
    "
  }
  
  #---------------------------------------------------------------------------
  # 4. HTTP ì‘ë‹µ ì½”ë“œ ê¸°ë°˜ ê²°ê³¼ íŒë‹¨
  #---------------------------------------------------------------------------
  if [http][response][status_code] {
    ruby {
      code => "
        status_code = event.get('[http][response][status_code]').to_i
        has_attack_tag = event.get('tags').include?('attack')
        
        if has_attack_tag
          # ê³µê²© ì‹œë„ê°€ íƒì§€ëœ ê²½ìš°
          if status_code >= 200 && status_code < 300
            event.set('[event][outcome]', 'success')      # ê³µê²© ì„±ê³µ (ìœ„í—˜!)
            event.set('[attack][executed]', true)
          else
            event.set('[event][outcome]', 'failure')      # ê³µê²© ì°¨ë‹¨ë¨ (ì•ˆì „)
            event.set('[attack][executed]', false)
          end
        else
          # ì •ìƒ íŠ¸ëž˜í”½
          if status_code >= 200 && status_code < 400
            event.set('[event][outcome]', 'success')      # ì •ìƒ ì„±ê³µ
          else
            event.set('[event][outcome]', 'failure')      # ì •ìƒ ì—ëŸ¬
          end
        end
      "
    }
  }
  
  #---------------------------------------------------------------------------
  # 5. ìµœì¢… ì •ì œ
  #---------------------------------------------------------------------------
  
  # íŒŒì‹± ìƒíƒœ íƒœê¹…
  if "_grokparsefailure" in [tags] {
    mutate {
      add_tag => ["parse_error"]
      add_field => { "parse_status" => "failed" }
    }
  } else {
    mutate {
      add_field => { "parse_status" => "success" }}
  }

    # ë¶ˆí•„ìš”í•œ í•„ë“œ ì œê±°
  mutate {
    remove_field => ["ident", "auth", "rawrequest"]
  }
}

#==============================================================================
# OUTPUT
#==============================================================================
output {
  # OpenSearchë¡œ ë©”ì¸ ë°ì´í„° ì „ì†¡
  elasticsearch {
    hosts => ["https://${OPENSEARCH_HOST}"]
    index => "${PROJECT_NAME}-siem-%{+yyyy.MM.dd}"     # âœ… í™˜ê²½ë³€ìˆ˜ ì‚¬ìš©
    
    # IAMìœ¼ë¡œ ë³€ê²½
#    auth_type => {
#      type => 'aws_iam' 
#      region => "${AWS_REGION}"
#    }
    
    ecs_compatibility => disabled
    
    retry_on_conflict => 3
  }
  
  # ðŸ”¥ ìˆ˜ì •: CloudWatch ë©”íŠ¸ë¦­ ì„¤ì •ìœ¼ë¡œ ë³€ê²½
  if "parse_error" in [tags] {
    cloudwatch {
      metricname => "ParseErrors"                    # log_group_name ëŒ€ì‹ 
      namespace => "SIEM/Logstash"                   # ë„¤ìž„ìŠ¤íŽ˜ì´ìŠ¤
      region => "${AWS_REGION}"
      unit => "Count"                                # ë‹¨ìœ„
      value => "1"                                   # ê°’
      
      # ì„ íƒì‚¬í•­: ì°¨ì› ì¶”ê°€
      dimensions => { 
        "Environment" => "Test"
        "Project" => "${PROJECT_NAME}"
      }
    }
  }
}