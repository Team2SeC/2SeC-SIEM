# Logstash Pipeline
# Kinesis (gzip) → CloudWatch JSON → split(logEvents) → grok/geoip → OpenSearch

input {
  kinesis {
    kinesis_stream_name => "${KINESIS_STREAM_NAME}"
    region              => "${AWS_REGION}"
    application_name    => "${APPLICATION_NAME}"

    codec => gzip {
      charset => "UTF-8"
    }
  }
}

filter {

  # --------------------------------------------------
  # 공통 메타데이터
  # --------------------------------------------------
  mutate {
    add_field => { "ingest_source" => "kinesis" }
  }

  # --------------------------------------------------
  # CloudWatch JSON 파싱
  # --------------------------------------------------
  json {
    source         => "message"
    target         => "parsed"
    tag_on_failure => ["_cloudwatch_json_failure"]
  }

  # --------------------------------------------------
  # dvwa-app 로그만 대상으로 처리 (⭐ split 전에 drop)
  # --------------------------------------------------
  if ![parsed][logStream] or [parsed][logStream] !~ "dvwa-app" {
    drop { }
  }

  # --------------------------------------------------
  # logEvents 배열 분리 (⭐ 핵심)
  # 이벤트 1개 = 웹 로그 1줄
  # --------------------------------------------------
  if [parsed][logEvents] {
    split { field => "[parsed][logEvents]" }
  } else {
    drop { }
  }

  # --------------------------------------------------
  # CloudWatch logEvent timestamp를 @timestamp로 보정
  # (UNIX_MS 기반)
  # --------------------------------------------------
  if [parsed][logEvents][timestamp] {
    date {
      match  => ["[parsed][logEvents][timestamp]", "UNIX_MS"]
      target => "@timestamp"
    }
  }

  # --------------------------------------------------
  # 실제 웹 로그 메시지 추출
  # --------------------------------------------------
  mutate {
    rename => { "[parsed][logEvents][message]" => "raw_message" }
  }

  # --------------------------------------------------
  # Web Access Log 파싱 (COMBINEDAPACHELOG)
  # --------------------------------------------------
  grok {
    match => { "raw_message" => "%{COMBINEDAPACHELOG}" }
    remove_field => ["timestamp"]
    tag_on_failure => ["_grok_web_failed"]
  }

  # grok 실패 이벤트는 일단 유지(디버깅).
  # 운영에서 깨끗한 데이터만 원하면 아래 주석 해제:
  # if "_grok_web_failed" in [tags] { drop {} }

  # --------------------------------------------------
  # SIEM 스키마 정규화
  # - clientip/verb/response/bytes/referrer/agent 등 표준화
  # - request는 'GET /path?query HTTP/1.1' 형태이므로
  #   url.original은 path+query로 재구성해서 "원문 URL"로 유지
  # --------------------------------------------------

  # clientip → ECS 유사: source.address
  mutate {
    rename => {
      "clientip" => "[source][address]"
      "verb"     => "[http][request][method]"
      "response" => "[http][response][status_code]"
      "bytes"    => "[http][response][body][bytes]"
      "referrer" => "[http][request][referrer]"
      "agent"    => "[user_agent][original]"
    }
  }

 grok {
    match => {
      "raw_message" =>
        "\"%{WORD:[http][request][method]} %{URIPATH:url.path}(?:\?%{DATA:url.query})? HTTP/%{NUMBER:http.version}\""
    }
  }

  if [url][path] and [url][query] {
    mutate { replace => { "[url][original]" => "%{[url][path]}?%{[url][query]}" } }
  } else if [url][path] {
    mutate { replace => { "[url][original]" => "%{[url][path]}" } }
  }

  if [source][address] {
    geoip {
      source => "[source][address]"
      target => "geoip"
    }
  }
}

output {
  opensearch {
    hosts => ["https://${OPENSEARCH_HOST}:443"]
    index => "2sec-siem-%{+yyyy.MM.dd}"

    auth_type => {
      type   => "aws_iam"
      region => "${AWS_REGION}"
    }

    ecs_compatibility => disabled
    manage_template   => false
  }
}