# Logstash Pipeline
# Kinesis (gzip) → CloudWatch JSON → split(logEvents) → grok/geoip → OpenSearch

input {
  kinesis {
    kinesis_stream_name => "${KINESIS_STREAM_NAME}"
    region              => "${AWS_REGION}"
    application_name    => "${APPLICATION_NAME}"

    codec => gzip {
      charset => "UTF-8"
    }
  }
}

filter {

  # --------------------------------------------------
  # 공통 메타데이터
  # --------------------------------------------------
  mutate {
    add_field => { "ingest_source" => "kinesis" }
  }

  # --------------------------------------------------
  # CloudWatch JSON 파싱
  # --------------------------------------------------
  json {
    source         => "message"
    target         => "parsed"
    tag_on_failure => ["_jsonparsefailure"]
  }

  # JSON 파싱 실패는 일단 남기고(디버깅), 운영에서는 drop 고려 가능
  # if "_jsonparsefailure" in [tags] { drop {} }

  # --------------------------------------------------
  # dvwa-app 로그만 대상으로 처리 (⭐ split 전에 drop)
  # --------------------------------------------------
  if ![parsed][logStream] or [parsed][logStream] !~ "dvwa-app" {
    drop { }
  }

  # --------------------------------------------------
  # logEvents 배열 분리 (⭐ 핵심)
  # 이벤트 1개 = 웹 로그 1줄
  # --------------------------------------------------
  if [parsed][logEvents] {
    split { field => "[parsed][logEvents]" }
  } else {
    drop { }
  }

  # --------------------------------------------------
  # CloudWatch logEvent timestamp를 @timestamp로 보정
  # (UNIX_MS 기반)
  # --------------------------------------------------
  if [parsed][logEvents][timestamp] {
    date {
      match  => ["[parsed][logEvents][timestamp]", "UNIX_MS"]
      target => "@timestamp"
    }
  }

  # --------------------------------------------------
  # 실제 웹 로그 메시지 추출
  # --------------------------------------------------
  mutate {
    rename => { "[parsed][logEvents][message]" => "raw_message" }
  }

  # --------------------------------------------------
  # Web Access Log 파싱 (COMBINEDAPACHELOG)
  # --------------------------------------------------
  grok {
    match => { "raw_message" => "%{COMBINEDAPACHELOG}" }
    tag_on_failure => ["_grok_web_failed"]
  }

  # grok 실패 이벤트는 일단 유지(디버깅).
  # 운영에서 깨끗한 데이터만 원하면 아래 주석 해제:
  # if "_grok_web_failed" in [tags] { drop {} }

  # --------------------------------------------------
  # SIEM 스키마 정규화
  # - clientip/verb/response/bytes/referrer/agent 등 표준화
  # - request는 'GET /path?query HTTP/1.1' 형태이므로
  #   url.original은 path+query로 재구성해서 "원문 URL"로 유지
  # --------------------------------------------------

  # clientip → ECS 유사: source.address
  mutate {
    rename => {
      "clientip" => "[source][address]"
      "verb"     => "[http][request][method]"
      "response" => "[http][response][status_code]"
      "bytes"    => "[http][response][body][bytes]"
      "referrer" => "[http][request][referrer]"
      "agent"    => "[user_agent][original]"
    }
  }

  # request 필드에서 path/query 분리
  # request 예: "/index.php?id=1"
  # COMBINEDAPACHELOG에서는 request 필드가 "GET /... HTTP/1.1"이 아니라
  # "request" 필드는 일반적으로 "/path?query" 형태로 들어오기도 하는데,
  # 환경마다 달라서 둘 다 커버하도록 처리합니다.

  # 1) request가 "/path?query" 형태인 경우
  if [request] {
    grok {
      match => { "request" => "^%{URIPATH:url.path}(?:\?%{DATA:url.query})?$" }
    }
  }

  # 2) raw_message에서 "GET /path?query HTTP/1.1" 형태로 들어오는 경우 대비
  if ![url][path] and [raw_message] {
    grok {
      match => { "raw_message" => "\"%{WORD:[http][request][method]} %{URIPATH:url.path}(?:\?%{DATA:url.query})? HTTP/%{NUMBER:http.version}\"" }
    }
  } else {
    # http.version은 raw_message에서 별도로 추출
    grok {
      match => { "raw_message" => "HTTP/%{NUMBER:http.version}" }
    }
  }

  # url.original 재구성 (path + ? + query)
  if [url][path] and [url][query] {
    mutate { replace => { "[url][original]" => "%{[url][path]}?%{[url][query]}" } }
  } else if [url][path] {
    mutate { replace => { "[url][original]" => "%{[url][path]}" } }
  }

  # --------------------------------------------------
  # GeoIP
  # --------------------------------------------------
  if [source][address] {
    geoip {
      source => "[source][address]"
      target => "geoip"
    }
  }

  # --------------------------------------------------
  # 공격 패턴 탐지 (1차 - SQLi)
  # --------------------------------------------------
  if [url][query] and [url][query] =~ "(?i)(union\s+select|or\s+1=1|--|/\*|\*/|'|\")" {
    mutate { add_field => { "attack_pattern" => "SQLi_suspected" } }
  } else {
    mutate { add_field => { "attack_pattern" => "none" } }
  }

  # --------------------------------------------------
  # 태그
  # --------------------------------------------------
  mutate {
    add_tag => ["web", "dvwa"]
  }
}

output {
  opensearch {
    hosts => ["https://${OPENSEARCH_HOST}:443"]
    index => "2sec-siem-%{+yyyy.MM.dd}"

    auth_type => {
      type   => "aws_iam"
      region => "${AWS_REGION}"
    }

    ecs_compatibility => disabled
    manage_template   => false
  }

  # 디버깅 필요할 때만 주석 해제
  # stdout { codec => rubydebug }
}