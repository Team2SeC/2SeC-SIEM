#==============================================================================
# 2SeC SIEM Logstash Pipeline Configuration  
# Kinesis Data Stream â†’ Processing â†’ OpenSearch
#==============================================================================

input {
  kinesis {
    kinesis_stream_name => "${KINESIS_STREAM_NAME}"
    region => "${AWS_REGION}"
    application_name => "${PROJECT_NAME}-logstash-consumer"
    
    codec => json
    tags => ["kinesis", "raw"]  
  }
}

filter {
  #---------------------------------------------------------------------------
  # 1. ê¸°ë³¸ í•„ë“œ ì •ë¦¬
  #---------------------------------------------------------------------------
  mutate {
    remove_field => ["@version", "host", "path", "port", "type"]
    add_field => {
      "pipeline" => "${PROJECT_NAME}-logstash"
      "[event][kind]" => "event"
      "[event][category]" => "web"
      "[event][dataset]" => "web.access"
    }
  }
  
  # íƒ€ìž„ìŠ¤íƒ¬í”„ ì •ê·œí™”
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601"]
      target => "@timestamp"
    }
  }
  
  #---------------------------------------------------------------------------
  # 2. ì›¹ ë¡œê·¸ íŒŒì‹± (Apache/Nginx Combined Log)
  #---------------------------------------------------------------------------
  if [log_type] == "web" {
    grok {
      match => { 
        "message" => "%{IPORHOST:[source][ip]} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] \"(?:%{WORD:[http][request][method]} %{NOTSPACE:[url][original]}(?: HTTP/%{NUMBER:[http][version]})?|%{DATA:rawrequest})\" %{NUMBER:[http][response][status_code]} (?:%{NUMBER:[http][response][body][bytes]}|-) \"(?:%{DATA:[http][request][referrer]}|-)\" \"(?:%{DATA:[user_agent][original]}|-)\""
      }
      add_tag => ["web_parsed"]
    }
    
    # URL íŒŒì‹±
    if [url][original] {
      ruby {
        code => "
          require 'uri'
          url = event.get('[url][original]')
          begin
            uri = URI.parse(url)
            event.set('[url][path]', uri.path)
            event.set('[url][query]', uri.query) if uri.query
          rescue => e
            event.tag('url_parse_error')
          end
        "
      }
    }
    
    # User Agent íŒŒì‹±
    if [user_agent][original] {
      useragent {
        source => "[user_agent][original]"
        target => "[user_agent]"
      }
    }
    
    # GeoIP ë¶„ì„
    if [source][ip] {
      geoip {
        source => "[source][ip]"
        target => "[source][geo]"
      }
    }
  }
  
  
  #---------------------------------------------------------------------------
  # 3. ðŸŽ¯ YAML ê¸°ë°˜ ê³µê²© íƒì§€ ì—”ì§„ (ì˜êµ¬ ë¶ˆë³€!)
  #---------------------------------------------------------------------------
  ruby {
    init => "
      begin
        # âœ… ì ˆëŒ€ ê²½ë¡œ ì‚¬ìš© (require_relative ëŒ€ì‹ )
        require '/usr/share/logstash/config/patterns/pattern_matcher.rb'
        
        # âœ… íŒŒì¼ ì¡´ìž¬ í™•ì¸
        pattern_file = '/usr/share/logstash/config/patterns/attack_patterns.yml'
        severity_file = '/usr/share/logstash/config/patterns/severity_mapping.yml'
        
        unless File.exist?(pattern_file)
          puts '[ERROR] Attack patterns file not found: #{pattern_file}'
          @pattern_matcher = nil
        else
          unless File.exist?(severity_file)
            puts '[ERROR] Severity mapping file not found: #{severity_file}'
            @pattern_matcher = nil
          else
            # âœ… ì•ˆì „í•œ ì´ˆê¸°í™”
            @pattern_matcher = AttackPatternMatcher.new(pattern_file, severity_file)
            puts '[INFO] Attack detection engine initialized successfully'
          end
        end
        
      rescue LoadError => e
        puts '[ERROR] Failed to load pattern matcher: #{e.message}'
        @pattern_matcher = nil
      rescue => e
        puts '[ERROR] Attack detection engine initialization failed: #{e.message}'
        @pattern_matcher = nil
      end
    "
    
    code => "
      begin
        # ë©”ì‹œì§€ ë° ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ì¶”ì¶œ
        message = event.get('message').to_s
        source_ip = event.get('[source][ip]')
        
        # âœ… ì—”ì§„ ìƒíƒœ í™•ì¸
        if @pattern_matcher.nil?
          # ì—”ì§„ ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ì²˜ë¦¬
          event.set('[event][type]', 'access')
          event.set('[event][outcome]', 'success')
          event.set('severity', 'info')
          event.set('[engine][status]', 'disabled')
          event.set('[engine][reason]', 'initialization_failed')
          event.tag('normal', 'engine_disabled')
        else
          # ðŸš€ ì •ìƒ ê³µê²© íƒì§€ ì‹¤í–‰
          detected_attacks = @pattern_matcher.detect_attacks(message, source_ip)
          
          if detected_attacks.empty?
            #-----------------------------------------------------------------------
            # ì •ìƒ íŠ¸ëž˜í”½ ì²˜ë¦¬
            #-----------------------------------------------------------------------
            event.set('[event][type]', 'access')
            event.set('[event][outcome]', 'success')
            event.set('severity', 'info')
            event.set('[engine][status]', 'active')
            event.tag('normal')
            
          else
            #-----------------------------------------------------------------------  
            # ê³µê²© íƒì§€ ì²˜ë¦¬
            #-----------------------------------------------------------------------
            event.set('[event][type]', 'attack')
            event.set('[event][outcome]', 'unknown')
            event.set('[engine][status]', 'active')
            
            # ê°€ìž¥ ì‹¬ê°í•œ ê³µê²© ì •ë³´ë¥¼ ë©”ì¸ìœ¼ë¡œ ì„¤ì •
            primary_attack = detected_attacks.first
            event.set('severity', primary_attack['severity'])
            event.set('[attack][category]', primary_attack['category'])
            event.set('[attack][technique]', primary_attack['technique'])
            event.set('[attack][confidence]', primary_attack['confidence'])
            
            # ë‹¤ì¤‘ ê³µê²© íƒì§€ ì‹œ ì¶”ê°€ ì •ë³´ ì €ìž¥
            if detected_attacks.size > 1
              event.set('[attack][multiple_detected]', true)
              event.set('[attack][count]', detected_attacks.size)
              
              # ëª¨ë“  ê³µê²© ì •ë³´ë¥¼ ë°°ì—´ë¡œ ì €ìž¥
              all_attacks = detected_attacks.map do |attack|
                {
                  'category' => attack['category'],
                  'technique' => attack['technique'], 
                  'severity' => attack['severity'],
                  'confidence' => attack['confidence']
                }
              end
              event.set('[attack][all_detected]', all_attacks)
              
              # ê³µê²© ì¹´í…Œê³ ë¦¬ ëª©ë¡ (ì§‘ê³„ìš©)
              categories = detected_attacks.map { |a| a['category'] }.uniq
              event.set('[attack][categories]', categories)
            end
            
            event.tag('attack')
          end
        end
        
      rescue => e
        # âœ… ëŸ°íƒ€ìž„ ì—ëŸ¬ ì²˜ë¦¬
        puts '[ERROR] Attack detection runtime error: #{e.message}'
        event.set('[event][type]', 'access')
        event.set('[event][outcome]', 'success') 
        event.set('severity', 'info')
        event.set('[engine][status]', 'error')
        event.set('[engine][error]', e.message)
        event.tag('normal', 'engine_error')
      end
    "
  }
  #---------------------------------------------------------------------------
  # 4. HTTP ì‘ë‹µ ì½”ë“œ ê¸°ë°˜ ê²°ê³¼ íŒë‹¨
  #---------------------------------------------------------------------------
  if [http][response][status_code] {
    ruby {
      code => "
        status_code = event.get('[http][response][status_code]').to_i
        has_attack_tag = event.get('tags').include?('attack')
        
        if has_attack_tag
          # ê³µê²© ì‹œë„ê°€ íƒì§€ëœ ê²½ìš°
          if status_code >= 200 && status_code < 300
            event.set('[event][outcome]', 'success')      # ê³µê²© ì„±ê³µ (ìœ„í—˜!)
            event.set('[attack][executed]', true)
          else
            event.set('[event][outcome]', 'failure')      # ê³µê²© ì°¨ë‹¨ë¨ (ì•ˆì „)
            event.set('[attack][executed]', false)
          end
        else
          # ì •ìƒ íŠ¸ëž˜í”½
          if status_code >= 200 && status_code < 400
            event.set('[event][outcome]', 'success')      # ì •ìƒ ì„±ê³µ
          else
            event.set('[event][outcome]', 'failure')      # ì •ìƒ ì—ëŸ¬
          end
        end
      "
    }
  }
  
  #---------------------------------------------------------------------------
  # 5. ìµœì¢… ì •ì œ
  #---------------------------------------------------------------------------
  
  # íŒŒì‹± ìƒíƒœ íƒœê¹…
  if "_grokparsefailure" in [tags] {
    mutate {
      add_tag => ["parse_error"]
      add_field => { "parse_status" => "failed" }
    }
  } else {
    mutate {
      add_field => { "parse_status" => "success" }}
  }

    # ë¶ˆí•„ìš”í•œ í•„ë“œ ì œê±°
  mutate {
    remove_field => ["ident", "auth", "rawrequest"]
  }
}

#==============================================================================
# OUTPUT
#==============================================================================
output {
  # OpenSearchë¡œ ë©”ì¸ ë°ì´í„° ì „ì†¡
  opensearch {
    hosts => ["https://${OPENSEARCH_HOST}:9200"]
    index => "${PROJECT_NAME}-siem-%{+yyyy.MM.dd}"     # âœ… í™˜ê²½ë³€ìˆ˜ ì‚¬ìš©
    
    # IAMìœ¼ë¡œ ë³€ê²½
    auth_type => {
      type => 'aws_iam' 
      region => "${AWS_REGION}"
    }
    
    ecs_compatibility => disabled
    
    retry_on_conflict => 3
  }
  
  # ðŸ”¥ ìˆ˜ì •: CloudWatch ë©”íŠ¸ë¦­ ì„¤ì •ìœ¼ë¡œ ë³€ê²½
  if "parse_error" in [tags] {
    cloudwatch {
      metricname => "ParseErrors"                    # log_group_name ëŒ€ì‹ 
      namespace => "SIEM/Logstash"                   # ë„¤ìž„ìŠ¤íŽ˜ì´ìŠ¤
      region => "${AWS_REGION}"
      unit => "Count"                                # ë‹¨ìœ„
      value => "1"                                   # ê°’
      
      # ì„ íƒì‚¬í•­: ì°¨ì› ì¶”ê°€
      dimensions => { 
        "Environment" => "Test"
        "Project" => "${PROJECT_NAME}"
      }
    }
  }
}