#==============================================================================
# 2SeC SIEM Logstash Pipeline Configuration
# CloudWatch Logs → Kinesis → Logstash → OpenSearch
# Ultra Defensive Version (handles JSON+base64+gzip, raw-gzip, deadletter)
#==============================================================================

############################
# INPUT
############################
input {
  kinesis {
    kinesis_stream_name => "${KINESIS_STREAM_NAME}"
    region              => "${AWS_REGION}"
    application_name    => "${APPLICATION_NAME}"

    # Kinesis 레코드를 문자열로 받되, 바이너리 깨짐 방지를 위해 ISO-8859-1로 1:1 매핑
    # => 바이너리 데이터를 1:1로 보존해서 압축 해제하도록 ASCII-8BIT로 변경
    codec => plain { charset => "ASCII-8BIT" }

    tags => ["kinesis", "cloudwatch"]
  }
}

############################
# FILTER
############################
filter {

  ###########################################################################
  # 0 원본 보존 (사후 분석/보고서용)
  ###########################################################################
  mutate {
    add_field => { "[@metadata][raw_message]" => "%{message}" }
  }

  ###########################################################################
  # 1 CloudWatch/Kinesis payload decode (3-case)
  #   Case A: JSON {"awslogs":{"data":"base64(gzip(json))"}}
  #   Case B: raw gzip bytes (message begins with 1F 8B)
  #   Case C: base64-only string that decodes to gzip(json)
  ###########################################################################
  ruby {
    code => "
      require 'json'
      require 'base64'
      require 'zlib'
      require 'stringio'

      raw = event.get('message')
      raw = raw.to_s
      raw.force_encoding('ASCII-8BIT')  # 바이너리 안전 처리

      decoded_payload = nil
      reason = nil

      # ---- Case B: raw gzip bytes ----
      if raw.bytesize >= 2 && raw.getbyte(0) == 0x1f && raw.getbyte(1) == 0x8b
        begin
          decoded_payload = Zlib::GzipReader.new(StringIO.new(raw)).read
          event.tag('cw_raw_gzip')
        rescue => e
          reason = 'raw_gzip_decompress_failed'
          event.set('[deadletter][error]', e.message)
        end
      end

      # ---- Case A: JSON wrapper ----
      if decoded_payload.nil?
        begin
          parsed = JSON.parse(raw)

          if parsed.is_a?(Hash) && parsed['messageType'] == 'CONTROL_MESSAGE'
            event.tag('cw_control_message')
            event.set('[deadletter][reason]', 'control_message')
            return
          end

          if parsed.is_a?(Hash) && parsed.dig('awslogs','data')
            b64 = parsed['awslogs']['data']
            gz  = Base64.decode64(b64)
            gz.force_encoding('ASCII-8BIT')

            if gz.bytesize >= 2 && gz.getbyte(0) == 0x1f && gz.getbyte(1) == 0x8b
              decoded_payload = Zlib::GzipReader.new(StringIO.new(gz)).read
              event.tag('cw_subscription')
            else
              reason = 'awslogs_data_not_gzip'
            end
          else
            reason = 'no_awslogs_data'
          end
        rescue => e
          reason = 'json_parse_failed'
        end
      end

      # ---- Case C: base64-only ----
      if decoded_payload.nil?
        begin
          gz = Base64.decode64(raw)
          gz.force_encoding('ASCII-8BIT')
          if gz.bytesize >= 2 && gz.getbyte(0) == 0x1f && gz.getbyte(1) == 0x8b
            decoded_payload = Zlib::GzipReader.new(StringIO.new(gz)).read
            event.tag('cw_base64_only')
          else
            reason ||= 'base64_decoded_not_gzip'
          end
        rescue => e
          reason ||= 'base64_decode_failed'
          event.set('[deadletter][error]', e.message)
        end
      end

      if decoded_payload
        event.set('[@metadata][cw_payload]', decoded_payload)
        event.remove('message')
      else
        event.tag('cw_decode_failed')
        event.set('[deadletter][reason]', reason || 'unknown_decode_failure')
      end
    "
  }

  ###########################################################################
  # 2 cw_payload JSON 파싱
  ###########################################################################
  if [@metadata][cw_payload] {
    json {
      source => "[@metadata][cw_payload]"
      target => "cw"
      ecs_compatibility => disabled
    }
  }

  ###########################################################################
  # 3 logEvents 분해 + message 치환
  ###########################################################################
  if [cw][logEvents] {
    split { field => "[cw][logEvents]" }

    mutate {
      replace => { "message" => "%{[cw][logEvents][message]}" }
    }

    date {
      match  => ["[cw][logEvents][timestamp]", "UNIX_MS"]
      target => "@timestamp"
    }
  } else {
    # cw 파싱이 안 된 이벤트는 web grok로 가지 않게 표시
    mutate { add_tag => ["no_cw_logevents"] }
  }

  ###########################################################################
  # 4 Apache Combined grok (cw logEvents로 정규화된 message만)
  ###########################################################################
  if "no_cw_logevents" not in [tags] and "cw_decode_failed" not in [tags] and "cw_control_message" not in [tags] {
    grok {
      match => {
        "message" => "%{IPORHOST:[source][ip]} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:[http][timestamp]}\\] \"%{WORD:[http][request][method]} %{NOTSPACE:[url][original]} HTTP/%{NUMBER:[http][version]}\" %{NUMBER:[http][response][status_code]} (?:%{NUMBER:[http][response][body][bytes]}|-) \"(?:%{NOTSPACE:[http][request][referrer]}|-)\" \"%{DATA:[user_agent][original]}\""
      }
      add_tag => ["web_parsed"]
      ecs_compatibility => disabled
    }
  }

  ###########################################################################
  # 5 URL 파싱 / GeoIP (web_parsed 성공 시에만)
  ###########################################################################
  if "web_parsed" in [tags] and [url][original] {
    ruby {
      code => "
        require 'uri'
        begin
          uri = URI.parse(event.get('[url][original]'))
          event.set('[url][path]', uri.path)
          event.set('[url][query]', uri.query) if uri.query
        rescue
          event.tag('url_parse_error')
        end
      "
    }
  }

  if "web_parsed" in [tags] and [source][ip] {
    geoip {
      source => "[source][ip]"
      target => "[source][geo]"
      ecs_compatibility => disabled
    }
  }

  ###########################################################################
  # 6 공통 필드
  ###########################################################################
  mutate {
    add_field => {
      "pipeline"          => "${APPLICATION_NAME}"
      "[event][kind]"     => "event"
      "[event][category]" => "web"
      "[event][dataset]"  => "web.access"
    }

    remove_field => ["@version", "cw", "ident", "auth"]
  }

  ###########################################################################
  # 7 outcome (web_parsed일 때만)
  ###########################################################################
  if "web_parsed" in [tags] and [http][response][status_code] {
    ruby {
      code => "
        code = event.get('[http][response][status_code]').to_i
        event.set('[event][outcome]', code < 400 ? 'success' : 'failure')
      "
    }
  }

  ###########################################################################
  # 8 Attack Detection Rules (Classification Layer - Level 1)
  ###########################################################################
  if "web_parsed" in [tags] {

    # 공통 필드 초기화
    mutate {
      add_field => {
        "[detection][stage]"   => "classification"
        "[detection][source]"  => "logstash"
        "[detection][version]" => "v1.0"
      }
    }

    # ----- WEB-SQLI-001: SQL Injection -----
    if [url][query] =~ /(?i)(union\s+select|' or 1=1|' or '1'='1|sleep\(|benchmark\(|concat\(|group_concat\(|0x[0-9a-f]+|waitfor\s+delay|exec\(|execute\(|information_schema|sysobjects|syscolumns)/ {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-SQLI-001"
          "[attack][type]"       => "SQL Injection"
          "[attack][category]"   => "Injection"
          "[attack][severity]"   => "medium"
          "[attack][confidence]" => "medium"
        }
        add_tag => ["attack", "sqli"]
      }
    }

    # ----- WEB-XSS-001: Cross-Site Scripting -----
    if [url][query] =~ /(?i)(<script|<\/script>|javascript:|onerror=|onload=|onmouseover=|onfocus=|onblur=|onclick=|<img|<svg|<iframe|<object|<embed|%3Cscript|%3Cimg|%3Csvg|%3Ciframe|&#60;script&#62;|&#x3C;script&#x3E;)/ {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-XSS-001"
          "[attack][type]"       => "Cross-Site Scripting"
          "[attack][category]"   => "Client-Side"
          "[attack][severity]"   => "medium"
          "[attack][confidence]" => "medium"
        }
        add_tag => ["attack", "xss"]
      }
    }

    # ----- WEB-CMD-001: Command Injection -----
    if [url][query] =~ /(?i)(;|\||&&|\|\||`|\$\()(whoami|id|ls|cat|pwd|uname|hostname|ifconfig|netstat|ps|wget|curl|nc|bash|sh|dir|type|ipconfig|net|ping|tasklist|cmd|powershell)/ {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-CMD-001"
          "[attack][type]"       => "Command Injection"
          "[attack][category]"   => "Injection"
          "[attack][severity]"   => "high"
          "[attack][confidence]" => "high"
        }
        add_tag => ["attack", "cmdi"]
      }
    }

    # ----- WEB-PATH-001: Path Traversal / LFI -----
    if [url][path] =~ /\.\.\/|\.\.\\|%2e%2e/ or [url][query] =~ /(?i)(\.\.\/|\.\.\\|%2e%2e|\/etc\/passwd|boot\.ini|\/etc\/shadow|\/proc\/|C:\\|\.\.%2F)/ {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-PATH-001"
          "[attack][type]"       => "Path Traversal"
          "[attack][category]"   => "File Access"
          "[attack][severity]"   => "medium"
          "[attack][confidence]" => "medium"
        }
        add_tag => ["attack", "path_traversal"]
      }
    }

    # ----- WEB-SCAN-001: Web Scanning -----
    # 관리자 페이지, 민감 파일, 백업 경로, API 문서, 개발 경로 등 탐지
    if [url][path] =~ /(?i)(\/phpmyadmin|\/wp-admin|\/wp-login\.php|\/admin|\/administrator|\/manager|\/control-panel|\/cpanel|\/\.git|\/\.env|\/\.env\.production|\/config|\/configuration\.php|\/wp-config\.php|\/settings\.py|\/backup|\/backup\.zip|\/backup\.tar\.gz|\/db_backup\.sql|\/\.bak|\/old|\/api|\/api\/v1|\/api\/swagger|\/api-docs|\/swagger-ui|\/graphql|\/graphql-playground|\/test|\/dev|\/debug|\/phpinfo\.php|\/info\.php|\/test\.php|\/server-status|\/server-info|\/status|\/health|\/metrics)/ and [http][response][status_code] =~ /^(403|404)$/ {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-SCAN-001"
          "[attack][type]"       => "Web Scanning"
          "[attack][category]"   => "Reconnaissance"
          "[attack][severity]"   => "low"
          "[attack][confidence]" => "low"
        }
        add_tag => ["attack", "scan"]
      }
    }

    # ----- WEB-UA-001: Suspicious User-Agent -----
    # 취약점 스캐너, 디렉터리 브루트포스, 스크립트 클라이언트, 봇 등 탐지
    if [user_agent][original] =~ /(?i)(sqlmap|nikto|nmap|masscan|nessus|acunetix|nuclei|burp|zap|w3af|openvas|dirb|gobuster|wfuzz|dirsearch|ffuf|curl|wget|python-requests|python-urllib|Go-http-client|Apache-HttpClient|Java\/|libwww-perl|bot|spider|crawler|scraper|scanner|scrapy)/ {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-UA-001"
          "[attack][type]"       => "Suspicious User-Agent"
          "[attack][category]"   => "Reconnaissance"
          "[attack][severity]"   => "low"
          "[attack][confidence]" => "low"
        }
        add_tag => ["attack", "suspicious_ua"]
      }
    }

    # 명시적 스캐너 UA는 confidence 상승
    if [user_agent][original] =~ /(?i)(sqlmap|nikto|acunetix|nessus|nuclei|openvas)/ {
      mutate {
        update => { "[attack][confidence]" => "high" }
        update => { "[attack][severity]" => "medium" }
      }
    }

    # ----- WEB-404-001: Repeated 404 Access -----
    if [http][response][status_code] == "404" {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-404-001"
          "[attack][type]"       => "Repeated 404 Access"
          "[attack][category]"   => "Reconnaissance"
          "[attack][severity]"   => "low"
          "[attack][confidence]" => "low"
        }
        add_tag => ["attack", "repeated_404"]
      }
    }

    # ----- WEB-AUTH-001: Login Bruteforce -----
    # 일반 로그인, 관리자 로그인, API 인증, CMS별 로그인 경로 탐지
    if [url][path] =~ /(?i)(\/login\.php|\/login\.html|\/login|\/signin|\/sign-in|\/sign_in|\/logon|\/logon\.php|\/authenticate|\/authentication|\/auth|\/admin\/login|\/administrator\/login|\/wp-admin|\/wp-login\.php|\/manager\/login|\/control-panel\/login|\/api\/auth|\/api\/login|\/api\/v1\/authenticate|\/api\/v1\/token|\/oauth\/token|\/user\/login)/ and [http][request][method] == "POST" {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-AUTH-001"
          "[attack][type]"       => "Login Bruteforce"
          "[attack][category]"   => "Authentication Abuse"
          "[attack][severity]"   => "high"
          "[attack][confidence]" => "low"
        }
        add_tag => ["attack", "auth_bruteforce"]
      }
    }

    # 관리자 로그인 경로는 severity 더 높게
    if "auth_bruteforce" in [tags] and [url][path] =~ /(?i)(\/admin|\/administrator|\/wp-admin|\/manager)/ {
      mutate {
        update => { "[attack][severity]" => "critical" }
      }
    }

    # ----- WEB-TIMEOUT-001: Slow Request / Timeout -----
    if [http][response][status_code] == "408" {
      mutate {
        add_field => {
          "[attack][rule_id]"    => "WEB-TIMEOUT-001"
          "[attack][type]"       => "Slow Request"
          "[attack][category]"   => "Availability"
          "[attack][severity]"   => "medium"
          "[attack][confidence]" => "low"
        }
        add_tag => ["attack", "timeout"]
      }
    }

    # Confidence 조정 로직
    if "attack" in [tags] {
      ruby {
        code => "
          # 복수 공격 패턴 감지 시 confidence 상승
          attack_tags = event.get('tags').select { |t| t =~ /^(sqli|xss|cmdi|path_traversal|scan|suspicious_ua|repeated_404|auth_bruteforce|timeout)$/ }

          if attack_tags.length >= 2
            event.set('[attack][confidence]', 'high')
          end

          # URL 인코딩이 포함된 경우 confidence 상승
          url_query = event.get('[url][query]').to_s
          if url_query =~ /%[0-9a-fA-F]{2}/
            current_confidence = event.get('[attack][confidence]')
            if current_confidence == 'low'
              event.set('[attack][confidence]', 'medium')
            elsif current_confidence == 'medium'
              event.set('[attack][confidence]', 'high')
            end
          end
        "
      }
    }
  }
}

############################
# OUTPUT
############################
output {

  # 정상 인덱스: cw_control, decode_failed, no_logevents 제외
  if "cw_control_message" not in [tags] and "cw_decode_failed" not in [tags] and "no_cw_logevents" not in [tags] {
    opensearch {
      hosts => ["https://${OPENSEARCH_HOST}:443"]
      index => "2sec-siem-%{+yyyy.MM.dd}"
      auth_type => { type => "aws_iam" region => "${AWS_REGION}" }
      ecs_compatibility => disabled
      manage_template   => false
    }
  } else {
    # 격리 인덱스(Deadletter): 원본(raw_message) + reason 보존
    opensearch {
      hosts => ["https://${OPENSEARCH_HOST}:443"]
      index => "2sec-siem-deadletter-%{+yyyy.MM.dd}"
      auth_type => { type => "aws_iam" region => "${AWS_REGION}" }
      ecs_compatibility => disabled
      manage_template   => false
    }
  }
}